对象的内存布局
     在hotSpot虚拟机中，对象在堆中的内存布局可以划分为三个部分：对象头（Header），实例数据(Instance Data)，对齐填充(Padding)
     对象头：对象头的信息包含两类信息
          第一类：用于存储对象自身的运行时数据，如hashCode,GC分代年龄，锁状态标志，线程持有的锁，偏向锁ID，偏向时间戳等，这部分数据的长度在32位和
            64位的虚拟机中（未开启压缩指针）中分别为32个比特和64个比特，官网称他为"Mark Word"，对象需要存储的运行时数据很多，其实已经远远
            超过了32位和64位bitmap结构所能记录的最大限度，但是对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率
            MarkWord被设计成一个有动态定义的数据结构，以便在极小空间内存储尽可能多的数据，根据对象的状态服用自己的存储空间

            存储内容                              标记位                            状态
            对象的哈希码，对象的分代年龄              01                               未锁定
            指向锁记录的指针                        00                               轻量级锁
            指向重量级锁的指针                      10                               膨胀（重量级锁）
            空，不需要记录信息                      11                               GC标记
            偏向线程ID，偏向时间锁，分代年龄          01                               可偏向
          第二类：是类型指针，即对象指向他的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例
     实例数据：
          是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论从父类继承下去的，还是在子类中定义的字段都必须记录下来
          这部分的存储顺序会受到虚拟机分配策略参数（-XX： FieldsAllocationStyle参数）和字段在java源码中定义顺序的影响，HosSpot虚拟机
          默认分配顺序为longs/doubles,ints,shorts/chars,bytes/booleans.oops(Ordinary Object Pointers,OOPS),从以上默认的分配策略
          中可以看到，相同宽度的字段总是被分配到了一起存放，在满足这个前提条件下，在父类中定义的变量会出现在子类之前，如果HotSpot虚拟机的+XX：
          CompactFields参数值为true(默认就为true)，那子类之中比较窄的变量也允许插入父类变量的空隙之间，以节省出一点点空间
     对齐填充：
          这并不是必然存在的，也没有特别的意义，他仅仅起到了占位符的作用，由于hostSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍
          换句话说就是任何对象的大小必须是8的整数倍，对象头部分已经被精心设计成正好是8字节的整数倍，因此如果对象实例数据部分没有对齐的话，就需要通
          过对齐填充来不全
对象的访问定位
     句柄访问：
            使用句柄访问的话，java堆中将可能会划分出一块内存来作为句柄池，引用中存储的就是句柄池的对象句柄地址，对象句柄地址指向了具体对象
            优势：引用中存储的是稳定的句柄池地址，在对象被移动（垃圾收集时移动对象是非常普通的行为）时只会改变句柄中的实例数据指针，而引用本身是
                 不需要改变的
     直接指针：
            使用直接指针访问的话，java堆中对象的内存布局就不需要考虑如何放置访问类型数据的相关信息，引用中存储的就是对象的地址，如果访问对象本身
            的话，就不需要多一次间接访问的开销
            优势：直接指针来访问最大的好处就是速度更宽，它节省了一次指针定位的时间开销，由于对象访问在java中非常频繁，因此这类开销积少成多也是一
                 项极为可观的执行成本，就hotSpot而言，它主要使用直接指针的方式进行对象访问
