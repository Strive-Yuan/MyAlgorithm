#                            深入理解java虚拟机读书笔记

## 一.对象的内存布局

​     在hotSpot虚拟机中，对象在堆中的内存布局可以划分为三个部分：对象头（Header），实例数据(Instance Data)，对齐填充(Padding)

###        1.对象头

​                   对象头的信息包含两类信息

          第一类：用于存储对象自身的运行时数据，如hashCode,GC分代年龄，锁状态标志，线程持有的锁，偏向锁ID，偏向时间戳等，这部分数据的长度在32位和
                64位的虚拟机中（未开启压缩指针）中分别为32个比特和64个比特，官网称他为"Mark Word"，对象需要存储的运行时数据很多，其实已经远远
                超过了32位和64位bitmap结构所能记录的最大限度，但是对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率
                MarkWord被设计成一个有动态定义的数据结构，以便在极小空间内存储尽可能多的数据，根据对象的状态服用自己的存储空间
            存储内容                              标记位                            状态
            对象的哈希码，对象的分代年龄              01                               未锁定
            指向锁记录的指针                        00                               轻量级锁
            指向重量级锁的指针                      10                               膨胀（重量级锁）
            空，不需要记录信息                      11                               GC标记
            偏向线程ID，偏向时间锁，分代年龄          01                               可偏向
          
          第二类：是类型指针，即对象指向他的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例
###    2. 实例数据

​      是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论从父类继承下去的，还是在子类中定义的字段都必须记录下来
​      这部分的存储顺序会受到虚拟机分配策略参数（-XX： FieldsAllocationStyle参数）和字段在java源码中定义顺序的影响，HosSpot虚拟机
​      默认分配顺序为longs/doubles,ints,shorts/chars,bytes/booleans.oops(Ordinary Object Pointers,OOPS),从以上默认的分配策略
​      中可以看到，相同宽度的字段总是被分配到了一起存放，在满足这个前提条件下，在父类中定义的变量会出现在子类之前，如果HotSpot虚拟机的+XX：
​      CompactFields参数值为true(默认就为true)，那子类之中比较窄的变量也允许插入父类变量的空隙之间，以节省出一点点空间

###     3.对齐填充

​      这并不是必然存在的，也没有特别的意义，他仅仅起到了占位符的作用，由于hostSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍
​      换句话说就是任何对象的大小必须是8的整数倍，对象头部分已经被精心设计成正好是8字节的整数倍，因此如果对象实例数据部分没有对齐的话，就需要通
​      过对齐填充来不全

## 二.对象的访问定位

###      1.句柄访问：

​            使用句柄访问的话，java堆中将可能会划分出一块内存来作为句柄池，引用中存储的就是句柄池的对象句柄地址，对象句柄地址指向了具体对象
​            优势：引用中存储的是稳定的句柄池地址，在对象被移动（垃圾收集时移动对象是非常普通的行为）时只会改变句柄中的实例数据指针，而引用本身是
​                 不需要改变的

###      2.直接指针：

​            使用直接指针访问的话，java堆中对象的内存布局就不需要考虑如何放置访问类型数据的相关信息，引用中存储的就是对象的地址，如果访问对象本身
​            的话，就不需要多一次间接访问的开销
​            优势：直接指针来访问最大的好处就是速度更宽，它节省了一次指针定位的时间开销，由于对象访问在java中非常频繁，因此这类开销积少成多也是一
​                 项极为可观的执行成本，就hotSpot而言，它主要使用直接指针的方式进行对象访问

## 三.引用

​         如果reference类型的数据存储的数据代表的是另外一块内存的起始地址，就成为该reference数据是代表某块内存，某个对象的引用，这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在这种定义下只有"被引用"或者"未被引用"两种状态，对于描述一些"食之无味，弃之可惜"的对象就闲的无能为力，譬如我们希望能描述一类对象:当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后依然非常紧张，那就可以抛弃这些对象-很多系统的缓存功能都符合这样的应用场景

​        在JDK1.2以后，java对引用进行了扩充，将引用分为强引用（Stringly Re-ference），软引用（Soft Reference）,弱引用（Phantom Reference）4种。这四种引用的强度依次逐渐减弱

### 1.强引用

  **强引用**：强引用是最传统的引用定义，是指在程序代码之中普通存在的引用赋值，即类似"Object obj = new Object()"这种引用关系，无论在任何情况下只要强引用还存在，垃圾回收期就永远不会回收被引用的对象

### 2.软引用

 （2）**软引用**：软引用是用来描述一些还有用，但非必须的对象，只被弱引用关联着的对象，在系统将要发生内存溢出的异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没足够的内存，才会抛出内存溢出异常在JDK1.2版本之后提供了SoftReference类来实现软引用

### 3.弱引用

 （3）**弱引用**：弱引用也是用来描述那些非必须对象，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，当前无论内存是否足够，都会回收掉只被弱引用关联的对象，在JDK1.2版本之后提供了WeakReference类来实现弱引用

### 4.虚引用

（4）**虚引用**：虚引用也成为"幽灵引用"或者"幻影引用"，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用关联的位置目的只是为了能在这个对象被收集器收集时受到一个系统通知。在JDK1.2版本之后提供了PhantomReference类来实现虚引用



## 四.判定对象存活的算法

### 1.引用计数算法

   **引用计数算法**: 在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时技，计数器就减1

​             缺点：无法解决循环引用的问题

### 2.可达性分析

   **可达性分析**：通过一系列成为"GC Roots"的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径成为"引用链"，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来书就是从GC Roots到这个对象时不可达的，则证明此对象是不可能再被使用的

```
GC Roots对象包括以下几类
1.在虚拟机栈中(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等
2.在方法区中类的静态属性引用的对象，譬如java类引用类型的静态变量
3.在方法区中常量引用的对象，譬如字符串常量池里的引用
4.在本地方法栈中JNI(即通常所说的Native方法)引用的对象
5.java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExecption,OutOfMemory Error等)，还有系统类加载器
6.所有被同步锁(synchronized关键字)持有的对象
7.反映java虚拟机内部情况的JMXBean,JVMTI中注册的回调，本地代码缓存等
除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象"临时性"加入，共同构成完成GC Roots集合。譬如后文将会提到的分代收集和局部回收(Partial GC),如果只针对java堆中某一块去语发起垃圾收集时(最典型的就只针对新生代的垃圾收集)，必须考虑到内存区域是虚拟机自己实现的细节(在用户视角里任何内存区域都是不可见的)，更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所因哟个，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性
```

## 五.对象存活？

​    即使在可达性分析算法中判定为不可达的对象，也不是"非死不可"，这时候他们暂时还处于"缓刑"阶段，要真正宣告一个对象的死亡，必须经历两次标记过程，如果对象在进行可达性分析后发现没有与GC Roots相链接的引用链，那么它会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，假如对象没有覆盖finalize()方法，或者finalize()已经被虚拟机调用过了，那么这两种情况都被视为没必要执行。

如果这个对象被判定有必要执行finalize()方法，那么该对象会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立，低调度优先级的finalizer线程去执行他们的finalize()方法，这里的执行是指虚拟机会触发finalize()开始运行，但并不承诺一定会等到它运行结束，这样的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端的发生了死循环，将可能F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收子系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中成功拯救自己，只需要重新与引用链的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那么第二次标记时它将被移除"即将回收"的集合

注：finalize()方法只会被调用一次

## 六.分代收集理论

   当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）[1]的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

### 1.弱分代假说

**弱分代假说（Weak Generational Hypothesis）: 绝大多数对象都是朝生夕灭**

### 2.强分代假说

**强分代假说（Strong Generational Hypoyhesis）:  熬过越多次的垃圾收集过程的对象就越难以消亡**

###  3. 跨代引用假说

​          **跨代引用**：对象之间会跨代引用，假如要现在进行一次只局限于新生代区域内的收集（minor GC），但新生代中的对象时完全有可能被老年代所引用的，为了找出该区域的存货对象，不得不在固定的GC Roots之外，在额外遍历整个老年代对象中所有对象来确保可达性分析结果的正确性。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担，为了解决这个问题需要堆分代收集理论添加第三条经验法则：

 **跨代引用假说(Intergenerational Reference Hypothesis)：跨代引用相对于同代引用来说仅占极少数**

​        隐含推论：存在互相引用关系的两个对象模式应该倾向于同时生存或者同时消亡的，举个例子，如果某新生代对象存在跨代引用,由于老年代对象难以消亡，改引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了

​       根据这条假说，我们就不应该为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门积累每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被成为记忆表,Remembered Set)，这个接口吧老年代划分为若干小块，标识出劳您阿呆的那一块内存会存在跨代引用。此后发生Minor Gc时，只有包含跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描，虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说依然是划算的

 **部分收集( Partial GC ): 指目标并不是完整收集整个java堆的垃圾收集包括**

- **新生代收集(Minor GC/Young GC)**: 指目标只是新生代收集
- **老年代收集(Major GC/Old GC)**: 指目标只是老年代收集，目前只有CMS收集器才会有单独收集老年代的行为，另外注意"Major GC"这个说法有点混淆，在不同的资料上常有不同所指，读者需根据上下文区分到底时老年代收集还是整堆收集
- **混合收集(Mixed GC)**: 指目标收集整个新生代以及部分老年代的垃圾收集，目前只有G1收集器会有这种行为
- 

 **整堆收集(Full GC): 收集整个java堆和方法区的垃圾收集**

## 七.收集算法

### 1.标记-清除算法

**标记-清除算法：**算法分为“标记”和“清除”两个阶段：首先标记出所有需要回

收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

​         缺点: 1.执行效率不稳定

​                   2.空间碎片化的问题

### 2.标记-复制算法

**标记-复制算法：**标记-复制算法常被简称为复制算法。为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”（Semispace Copying）的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

​         优点：内存连续不存在碎片化

​         缺点：1.大量的内存间复制的开销

**HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1**         

**内存的分配担保机制：**当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。

### 3.标记-整理算法

**标记-整理算法**：标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”（Mark-Compact）算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存.如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World”



## 八.垃圾收集器

### 1.新生代收集器

####   1）Serial

​     是一个单线程工作的收集器 （几十兆甚至一两百兆）
​     新生代收集器采用复制算法，暂停所有用户线程
​     适用于内存受限制的环境，它是所有收集器额外内存消耗最小的收集器

####    2）ParNew

​     ParNew支持多线程并行收集，只能和CMS配合使用
​     新生代采用复制算法，暂停所有用户线程
​     老年代采用标记-整理算法，暂停所有用户线程
​     是Serial收集器的多线程并行版本，除了使用多线程进行垃圾收集之外，其他行为包括Serial收集器可用的所有控制参数，收集算法，stop the word,对象分配规则，回收策略等都与Serial收集器完全一致，在实现上两种收集器也共用了相当多的代码

####    3）Paraller Scavenge

​     采用标记-复制算法，并行收集
​     特点：它的关注点和其他的收集器不同，CMS等收集器的关注点是尽可能的缩 短垃圾收集时用户线程的停顿时间，而Paraller Scavenge收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值
​     吞吐量 = 运行用户代码时间/运行用户代码时间+运行垃圾收集时间

### 2.老年代收集器

#### 1）Serial Old

  是一个单线程工作的收集器
  老年代收集器采用标记-整理算法，暂停所有用户线程

#### 2）Paraller Old

  并发收集
  老年代收集器采用标记-整理算法，暂停所有用户线程、

#### 3）CMS

  并发收集

  CMS是一款基于“标记-清除”算法实现的收集器(三色标记算法)

  CMS(Concurrent Mark Sweep)收集器时一种以获取最短回收停顿时间为目标的收集器，目前很大一分部的java应用集中在互联网网站或者基于浏览器的B/S系统的服务器上，这类应用通常较为关注服务的相应速度，希望系统停顿时间尽可能段，以给用户带来良好的交互体验，CMS收集器就非常符合这类应用的要求
  收集过程：
     1）初始标记(CMS initial mark)
     2）并发标记(CMS concurrent mark)
     3）重新标记(CMS remark)
     4）并发清楚(CMS concurrent sweep)
     其中初始标记，重新标记这两个步骤依然需要"stop the word"，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快；并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时脚掌但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个停顿通常比初始标记稍长一些，但也远比并发标记阶段的时间短，最后是并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

​      缺点：

​        1）cms收集器对处理器资源非常敏感，事实上，面上并发设计的程序都对处理器资源比较敏感。再并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量。

​        2）CMS无法处理浮动垃圾，由于CMS收集器无法处理“浮动垃圾” Floating Garbage），有可能出现“Con-current ModeFailure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在实际应用中老年代增长并不是太快，可以适当调高参数-XX：CMSInitiatingOccu-pancyFraction的值来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。**到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。但这又会更容易面临另一种风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集，**

但这样停顿时间就很长了。所以参数-XX：CMSInitiatingOccupancyFraction设置得太高将会很容易导致

大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置

​       3）CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生

#### 4）G1

​        G1(Garbage First)收集器是垃圾收集器技术发展史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式，在G1收集器出现之前的所有其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。而G1跳出了这个樊笼，它可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式

G1开创的基于Region的堆内存布局是它能够实现这个目标的关键。**虽然G1也仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。**每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待，如图3-12所示。虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合。G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。

**G1收集器至少有（不限于）以下这些关键的细节问题需要妥善解决：**

1. 将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决？解决的思路我们已经知道：使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。G1的记忆集在存储结构的本质上是一种哈希表，Key是别的Region的起始地址，Value是一个集合，里面存储的元素是卡表的索引号。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。

2. 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？

   这里首先要解决的是用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误，该问题的解决办法笔者已经抽出独立小节来讲解过：CMS收集器采用增量更新算法实现，而G1收集器则是通过原始快照（SATB）算法来实现的。此外，垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。与CMS中的“Concurrent Mode Failure”失败会导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致Full GC而产生长时间“Stop The World”。



### 3.常用组合方式

  1.Serial + Serial Old
  2.ParNew + CMS
  3.Paraller Scavenge + Paraller Old

