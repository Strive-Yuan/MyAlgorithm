#                            深入理解java虚拟机读书笔记

#### 1.对象的内存布局

​     在hotSpot虚拟机中，对象在堆中的内存布局可以划分为三个部分：对象头（Header），实例数据(Instance Data)，对齐填充(Padding)

#####        （1）对象头

​                   对象头的信息包含两类信息

          第一类：用于存储对象自身的运行时数据，如hashCode,GC分代年龄，锁状态标志，线程持有的锁，偏向锁ID，偏向时间戳等，这部分数据的长度在32位和
                64位的虚拟机中（未开启压缩指针）中分别为32个比特和64个比特，官网称他为"Mark Word"，对象需要存储的运行时数据很多，其实已经远远
                超过了32位和64位bitmap结构所能记录的最大限度，但是对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率
                MarkWord被设计成一个有动态定义的数据结构，以便在极小空间内存储尽可能多的数据，根据对象的状态服用自己的存储空间
            存储内容                              标记位                            状态
            对象的哈希码，对象的分代年龄              01                               未锁定
            指向锁记录的指针                        00                               轻量级锁
            指向重量级锁的指针                      10                               膨胀（重量级锁）
            空，不需要记录信息                      11                               GC标记
            偏向线程ID，偏向时间锁，分代年龄          01                               可偏向
          
          第二类：是类型指针，即对象指向他的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例
#####    （2） 实例数据

​      是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论从父类继承下去的，还是在子类中定义的字段都必须记录下来
​      这部分的存储顺序会受到虚拟机分配策略参数（-XX： FieldsAllocationStyle参数）和字段在java源码中定义顺序的影响，HosSpot虚拟机
​      默认分配顺序为longs/doubles,ints,shorts/chars,bytes/booleans.oops(Ordinary Object Pointers,OOPS),从以上默认的分配策略
​      中可以看到，相同宽度的字段总是被分配到了一起存放，在满足这个前提条件下，在父类中定义的变量会出现在子类之前，如果HotSpot虚拟机的+XX：
​      CompactFields参数值为true(默认就为true)，那子类之中比较窄的变量也允许插入父类变量的空隙之间，以节省出一点点空间

#####     （3）对齐填充

​      这并不是必然存在的，也没有特别的意义，他仅仅起到了占位符的作用，由于hostSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍
​      换句话说就是任何对象的大小必须是8的整数倍，对象头部分已经被精心设计成正好是8字节的整数倍，因此如果对象实例数据部分没有对齐的话，就需要通
​      过对齐填充来不全

#### 2.对象的访问定位

#####      句柄访问：

​            使用句柄访问的话，java堆中将可能会划分出一块内存来作为句柄池，引用中存储的就是句柄池的对象句柄地址，对象句柄地址指向了具体对象
​            优势：引用中存储的是稳定的句柄池地址，在对象被移动（垃圾收集时移动对象是非常普通的行为）时只会改变句柄中的实例数据指针，而引用本身是
​                 不需要改变的

#####      直接指针：

​            使用直接指针访问的话，java堆中对象的内存布局就不需要考虑如何放置访问类型数据的相关信息，引用中存储的就是对象的地址，如果访问对象本身
​            的话，就不需要多一次间接访问的开销
​            优势：直接指针来访问最大的好处就是速度更宽，它节省了一次指针定位的时间开销，由于对象访问在java中非常频繁，因此这类开销积少成多也是一
​                 项极为可观的执行成本，就hotSpot而言，它主要使用直接指针的方式进行对象访问

#### 3.引用

​         如果reference类型的数据存储的数据代表的是另外一块内存的起始地址，就成为该reference数据是代表某块内存，某个对象的引用，这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在这种定义下只有"被引用"或者"未被引用"两种状态，对于描述一些"食之无味，弃之可惜"的对象就闲的无能为力，譬如我们希望能描述一类对象:当内存空间还足够时，能保留在内存之中，如果内存空间在进行垃圾收集后依然非常紧张，那就可以抛弃这些对象-很多系统的缓存功能都符合这样的应用场景

​        在JDK1.2以后，java对引用进行了扩充，将引用分为强引用（Stringly Re-ference），软引用（Soft Reference）,弱引用（Phantom Reference）4种。这四种引用的强度依次逐渐减弱

  （1）**强引用**：强引用是最传统的引用定义，是指在程序代码之中普通存在的引用赋值，即类似"Object obj = new Object()"这种引用关系，无论在任何情况下只要强引用还存在，垃圾回收期就永远不会回收被引用的对象

 （2）**软引用**：软引用是用来描述一些还有用，但非必须的对象，只被弱引用关联着的对象，在系统将要发生内存溢出的异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没足够的内存，才会抛出内存溢出异常在JDK1.2版本之后提供了SoftReference类来实现软引用

 （3）**弱引用**：弱引用也是用来描述那些非必须对象，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，当前无论内存是否足够，都会回收掉只被弱引用关联的对象，在JDK1.2版本之后提供了WeakReference类来实现弱引用

（4）**虚引用**：虚引用也成为"幽灵引用"或者"幻影引用"，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用关联的位置目的只是为了能在这个对象被收集器收集时受到一个系统通知。在JDK1.2版本之后提供了PhantomReference类来实现虚引用

#### 4.分代收集理论

   当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”（Generational Collection）[1]的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

##### （1）弱分代假说（Weak Generational Hypothesis）: 绝大多数对象都是朝生夕灭

##### （2）强分代假说（Strong Generational Hypoyhesis）:  熬过越多次的垃圾收集过程的对象就越难以消亡



