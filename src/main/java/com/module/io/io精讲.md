##                                       io精讲笔记

### 一.操作系统宏观介绍

   1.  **程序不能直接访问硬件，要通过系统调用**

   2. **（宏观维度）io比较重要的一些东西: cpu ，内存 ，io设备，磁盘 ，网卡**

   3. **（程序维度）kernel(内核) app(用户程序)**

      **  每个程序都是逻辑的 线性的地址，程序通过内核的系统调用获取数据**

   4. **vfs：**（虚拟文件系统） -- 目录树

      树上的每个节点可以映射到不同的物理位置，

      vfs的inode 文件（可以理解为id） 如何访问数据

   5. **pagecache：**  默认4K大小

      两个程序同时打开一个文件读取时，pageCache是一份，是共享的。

      dirty(脏的) ：pageCache已经被缓存了，当这个pageCache被修改后，这个pageCache就会标记成脏

   6. **flush(刷写)：**

      配置：

   7. **fd：** 文件描述符 ---->指针 seek   描述了打开文件的一些具体信息，偏移 指针

### 二.虚拟文件系统

​      冯诺依曼结构：计算器， 控制器，主存储器， 输入输出设备

##### 1.**文件类型**

-：普通文件（可以是可执行的，可以是图片，可以是文本）

d：目录

l：链接（分为软连接和硬链接）

​     ln: 硬链接   stat  可以看到某文件的源数据信息 看Inode号（理解为将一个文件增加一个引用）

​     ln -s：软连接

b：块设备(如果可以从一个设备读数据可以来回自由的读，不受约束就是一个块设备，比如 硬盘)

c：字符设备 CHR（如果读的时候读不到过去的有很多约束,需要编解码或驱动的约束，就是字符设备，比如 键盘）

s：socket

p: pipeline 管道

[eventpoll]：这个文件的类型就是内核提供的epoll的区域

。。。。。。。

  lsof命令： 可以显示进程打开了那些文件

任何程序: 0 标准输入 1 标准输出 2 报错输出

```
--------------------------------------------------------------------------
">" 单大于号，重定向符，没有命令在它之前，这会删除一个已存在文件的内容或是创建一个
新的空文件，作用是覆盖文件，将左侧的内容覆盖有右侧。上面命令由于左侧没有内容，因此将file清空了。如果有两个文件file1和file2，执行 cat file1 > file2，则将文件1的内容覆盖掉文件2的。因此">"左侧可以使用其它命令组合并将输出当做右侧文件的输入。

">>"用于覆盖，将左侧文件内容追加到右侧文件中。使用方式和单大于号相同。

"<"表示的是输入重定向的意思，就是把<后面跟的文件取代键盘作为新的输入设备。

-------------------------------------------------------------------------
head aa.text： 读aa文件前十行
head -1 aa.text： 读aa文件第一行
tail aa.text： 读aa文件后十行
head -1 aa.text： 读aa文件最后一行
没有读取文件中间某一行的命令
但可以通过管道 比如读第8行
head -8 aa.txt | tail -1

-------- -------------------------------------------------------------------
echo $BASGPID： 输出当前bash的进程号  优先级低于管道
echo $$ :输出当前bash的进程号  优先级高于管道
pstree: 
ps ef | grep 4398
pcstat: 可以监测一个文件是否在内存页高速缓存中
在进程中
x=100 临时变量
在子进程中
echo $x  去临时变量x的值 
结果读不到x
说明进程间互相隔离
可以通过环境变量让父子进程共享x变量

----------------------------------------------------------------------------
a=1
{a=9;echo "sdfsaf";} | cat 
echo $a 
结果为1
管道的机制： bash是解释执行，会解释文本段，解释的时候看到管道的时候 会在左边启动一个子进程右边启动一个子进程分别执行，然后两个进程的输入输出通过管道回到父进程
左边子进程执行后子进程中a=9跟父进程a没有关系
```



##### 2.**PageCache：4KB**

```
pageCache是内核维护的一个中间层
   使用多大内存？
   是否淘汰？
   是否延迟？
   是否丢数据？
   
配置： sysctl -a | grep dirty           
     vm.dirty_background_bytes = 0 
     vm.dirty_background_ratio = 90 //pagecache占用可用内存，当占用率大于90%的时候才会将pagecache刷写入磁盘（不会阻塞程序）
     vm.dirty_bytes = 0
     vm.dirty_ratio = 30 //分配pagecache时，当分配的内存占用了可用内存的百分之90时，会将pagecache刷写入磁盘（阻塞程序）
     vm.dirty_writeback_centisecs = 500 //5秒 5秒刷新一次
     vm.dirty_expire_centisecs = 3000 // back生命周期可以存多久
修改配置：vi /etc/sysctl.conf

mmap：堆外的且和文件映射的（mmap的内存映射依然是内核的pagecache体系所约束的）
       
    
```



###  三.TCP

##### 1.TCP协议

   tcp协议：是面向连接的，可靠的传输协议

   连接建立：三次握手之后，双方开辟资源(socket)

```
netstat命令:显示路由表、实际的网络连接以及每一个网络接口设备的状态信息 
-a或--all：显示所有连线中的Socket；
-A<网络类型>或--<网络类型>：列出该网络类型连线中的相关地址；
-c或--continuous：持续列出网络状态；
-C或--cache：显示路由器配置的快取信息；
-e或--extend：显示网络其他相关信息；
-F或--fib：显示FIB；
-g或--groups：显示多重广播功能群组组员名单；
-h或--help：在线帮助；
-i或--interfaces：显示网络界面信息表单；
-l或--listening：显示监控中的服务器的Socket；
-M或--masquerade：显示伪装的网络连线；
-n或--numeric：直接使用ip地址，而不通过域名服务器；
-N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称；
-o或--timers：显示计时器；
-p或--programs：显示正在使用Socket的程序识别码和程序名称；
-r或--route：显示Routing Table；
-s或--statistice：显示网络工作信息统计表；
-t或--tcp：显示TCP传输协议的连线状况；
-u或--udp：显示UDP传输协议的连线状况；
-v或--verbose：显示指令执行过程；
-V或--version：显示版本信息；
-w或--raw：显示RAW传输协议的连线状况；
-x或--unix：此参数的效果和指定"-A unix"参数相同；
--ip或--inet：此参数的效果和指定"-A inet"参数相同。
----------------------------------------------------------------------------------------------------------------------------
[root@VM-4-5-centos ~]# netstat -natp 
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN      1331/redis-server * 
tcp        0      0 127.0.0.1:6380          0.0.0.0:*               LISTEN      1332/redis-server 1 
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1298/sshd           
tcp        0      0 10.0.4.5:46872          169.254.0.138:8186      ESTABLISHED 1321/tat_agent      
tcp        0     52 10.0.4.5:22             183.14.28.48:23142      ESTABLISHED 30509/sshd: root@pt 
tcp6       0      0 :::2181                 :::*                    LISTEN      1812/java           
tcp6       0      0 :::3306                 :::*                    LISTEN      1671/mysqld         
tcp6       0      0 :::6379                 :::*                    LISTEN      1331/redis-server * 
tcp6       0      0 ::1:6380                :::*                    LISTEN      1332/redis-server 1 
tcp6       0      0 :::33005                :::*                    LISTEN      1812/java           
tcp6       0      0 :::8080                 :::*                    LISTEN      1812/java           
tcp6       0      0 :::22                   :::*                    LISTEN      1298/sshd           
tcp6       0      0 :::33060                :::*                    LISTEN      1671/mysqld 
---------------------------------------------------------------------------------------------------------------------------
1.Proto:协议名（tcp协议还是udp协议)；
2.recv-Q:网络接收队列
        表示收到的数据已经在本地接收缓冲，但是还有多少没有被进程取走，recv()如果接收队列Recv-Q一直处于阻塞状态，可能是遭受了拒绝服务 denial-of-service         攻击；
3.send-Q:网路发送队列
         对方没有收到的数据或者说没有Ack的,还是本地缓冲区.
         如果发送队列Send-Q不能很快的清零，可能是有应用向外发送数据包过快，或者是对方接收数据包不够快；
         这两个值通常应该为0，如果不为0可能是有问题的。packets在两个队列里都不应该有堆积状态。可接受短暂的非0情况。
4.Local Address 解释
         1)Local Address 部分的0.0.0.0:873表示监听服务器上所有ip地址的所有(0.0.0.0表示本地所有ip)，比如你的服务器是有172.172.230.210和
           172.172.230.11两个ip地址，那么0.0.0.0:873此时表示监听172.172.230.210,172.172.230.211,127.0.0.1三个地址的873端口
         2)127.0.0.1:25这个表示监听本机的loopback地址的25端口(如果某个服务只监听了回环地址，那么只能在本机进行访问，无法通过tcp/ip 协议进行远程访问)
         3)192.168.1.81:2288这是因为我们在启动的时候指定了192.168.1.81:2288参数，如果不指定的话，会监听0.0.0.0：2288
5.Foreign Address解释
         与本机端口通信的外部socket。显示规则与Local Address相同
6.State解释
         链路状态，共有11种
         state列共有12中可能的状态，前面11种是按照TCP连接建立的三次握手和TCP连接断开的四次挥手过程来描述的。
         (1)LISTEN ：首先服务端需要打开一个socket进行监听，状态为LISTEN. 侦听来自远方TCP端口的连接请求 
         (2)SYN_SENT：客户端通过应用程序调用connect进行activeopen.于是客户端tcp发送一个SYN以请求建立一个连接.之后状态SYN_SENT。在发送连接请求后等待                       匹配的连接请求 
         (3)SYN_RECV：服务端应发出ACK确认客户端的 SYN,同时自己向客户端发送一个SYN.之后状态置为SYN_RECV 在收到和发送一个连接请求后等待对连接请求的确认
         (4)ESTABLISHED：代表一个打开的连接，双方可以进行或已经在数据交互了。 代表一个打开的连接，数据可以传送给用户 
         (5)FIN_WAIT1：主动关闭(activeclose)端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态. 等待远程TCP的连接中断请                        求，或先前的连接中断请求的确认
         (6)CLOSE_WAIT：被动关闭(passiveclose)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序),并CLOSE_WAIT.等                        待从本地用户发来的连接中断请求
         (7)FIN_WAIT2：主动关闭端接到ACK后，就进入了FIN-WAIT-2  从远程TCP等待连接中断请求
         (8)LAST_ACK：被动关闭端一段时间后，接收到文件结束符的应用程序将调用CLOSE关闭连接。这导致它的TCP也发送一个 FIN,等待对方的ACK.就进入了LAST-                       ACK 、等待原来发向远程TCP的连接中断请求的确认
         (9)TIME_WAIT：在主动关闭端接收到FIN后，TCP 就发送ACK包，并进入TIME-WAIT状态。.等待足够的时间以确保远程TCP接收到连接中断请求的确认
         (10)CLOSING：比较少见.等待远程TCP对连接中断的确认 
         (11)CLOSED：被动关闭端在接受到ACK包后，就进入了closed的状态。连接结束.没有任何连接状态 
             UNKNOWN：未知的Socket状态。

```

##### 2.TCPIP参数

```
1.网络七层模型
-----------------------------------------
  应用层
  表示层          应用层：http，NDS
  会话层
  --------------------------------------
  传输层          主机到主机层：tcp,udp
  ----------------------------------------------
  网络层          internet层：IP,ICUP
  -------------------------------------
  数据链路层       网络接入层:internet     
  物理层
  ---------------------------------
2.TCP/IP：不是一个协议，而是一个协议族的统称。**里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等
         TCP/IP协议栈主要分为四层:应用层、传输层、网络层、数据链路层,每层都有相应的协议
3.UDP：UDP协议也是传输层协议，它是无连接，不保证可靠的传输层协议
```

### 四.网络io变化模型

1.同步，异步，阻塞，非阻塞

```
man命令 : 8类文档  man man 
man tcp 
ulimit -n 1024 为啥连接数可以超过1024？ root用户可以超出某些配置的限制
------------------------------------------------------------------------
BIO
1.socket：创建一个socket 返回一个文件描述符
2.bank:将文件描述符bind到某一个端口
3.listen： 监听这个文件描述符
4.accecpt：接受这个文件描述符上客户端的连接(客户端没有连接就会阻塞)
必须要单独抛出线程（主线程接收客户端的连接，单独抛出线程处理已连接的客户端发来的数据）
-------------------------------------------------------------------------
NIO
1.socket：创建一个socket 返回一个文件描述符
2.bank:将文件描述符bind到某一个端口
3.listen： 监听这个文件描述符
while{
4.accecpt：接受这个文件描述符上客户端的连接(不阻塞，返回-1|fd) (客户端需要设置nonblocking）
}
可以在一个线程中完成连接的接受和客户端消息的接收（不需要单独抛出线程）
--------------------------------------------------------------------------
多路复用器 select, poll


```

